def gitInfo() {
    def gitBranch = 'git rev-parse --abbrev-ref HEAD'.execute([], project.rootDir).text.trim()
    def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()
    def gitStatus = 'git status -z --ignore-submodules=untracked'.execute([], project.rootDir).text.trim()
    if (gitStatus.isEmpty()) {
        return gitBranch + "_" + gitSha
    } else {
        return gitBranch + "_" + gitSha + "_modified"
    }
}

android {
    applicationVariants.all { variant ->
        def buildType = variant.buildType.name
        def taskMiddleName = variant.variantData.name.capitalize()

        Task mergeAssets = tasks.findByName("merge${taskMiddleName}Assets")
        Task encodePlistArchives = tasks.create(name: "encode${taskMiddleName}PlistArchives",
                type: Exec,
                group: 'Color SMS',
                description: 'Perform plist -> pa conversion before merge{Variant}Assets tasks.') {
            commandLine '../plist-conv.sh'
            mergeAssets.outputs.upToDateWhen { false }
            // Clear mergeAssets task UP-TO-DATE status to force a re-run
        }
        mergeAssets.dependsOn encodePlistArchives

        if (buildType == 'release') {
            Task signApk = tasks.create(name: "sign${taskMiddleName}Apk",
                    type: Exec,
                    group: 'Themes',
                    description: 'Sign theme apk.') {
                commandLine './sign_message/sign_message.sh', variant.mergedFlavor.versionName
            }
            variant.assemble.finalizedBy signApk
        }
    }

    defaultConfig {
        buildConfigField "String", "GIT_INFO", "\"${gitInfo()}\""
    }
}
